// load "file_read.magma";
load "tables.magma";
load "innerFunction.magma";

// Marco Kolodziej
// Laden der Permutationen aus G64
// Um einen Vektor zu Permutieren muss nun <Vektor>^Permutation genommen werden
// Bsp: K:=FiniteField(2);
// V64:=VectorSpace(K, 64);
// t:=[Random(K):i in [1..64]];
// t^IP;
// ElementarBeispiel: t2:=[i: i in [1..64]];
// t2^IP; -> Werte stehen in der Reihenfolge wie in der Tabelle aus fips für IP
// IP_INVERSE natürlich analog.

G64:=Sym(64);
IP:=G64!ip;
IP_INVERSE:=G64!ip_inverse;

function enc_triple_DES(input, k1, k2, k3)
	return enc_DES(k3, dec_DES( k2, enc_DES(k1, input)));
end function;

function dec_triple_DES()
end function;

// Fuhr
function enc_DES(key, input)
	L0R0 := input^ip;
	V32 := VectorSpace(GF(2), 32);
	L := V32![ L0R0[i] : i in [1..32]];
	R := V32![ L0R0[i] : i in [33..64]];
	keys := generate_keys(key);

	for i in [1 .. 16] do
		L_old := L;
		R_old := R;
		L := R_old;
		R := L_old + inner_f(R_old, keys[i]);
    end for;

    return concatenate(R, L)^ip;
end function;

function dec_DES(key, input)
end function;

function split_data()
end function;

function concatenate(left, right)
	V64 := VectorSpace(GF(2), 64);
	return V64!([ left[i] : i in [1..32]] cat [ right[i] : i in [1..32]]);
end function;

function generate_keys(key)
	return keys;
end function;

